import vcf, os, sys, argparse
import pandas as pd
import numpy as np

parser = argparse.ArgumentParser()

# dest indicates the name that each argument is stored in so that you can access it after running .parse_args()
parser.add_argument('-i', type=str, dest='sample_dir', help='Lineage directory where all input and output files are', required=True)
parser.add_argument('-o', type=str, dest='F2_fName', help='Output text file to write the F2 metric to', required=True)
parser.add_argument('--lineage-file', dest='lineage_defining_SNPs_file', help='File of all lineage-defining SNPs for the Coll scheme', required=True)

cmd_line_args = parser.parse_args()
sample_dir = cmd_line_args.sample_dir
F2_fName = cmd_line_args.F2_fName
lineage_defining_SNPs_file = cmd_line_args.lineage_defining_SNPs_file


##########################################################################################################################################################


# Lineage Defining SNPs - Import full set of Lineage Defining SNP sets from Coll et. al. 2014
lineage_defining_SNPs = pd.read_csv(lineage_defining_SNPs_file).rename(columns={"#lineage": "lineage"})
lineage_defining_SNPs['lineage'] = [val.replace('lineage', '') for val in lineage_defining_SNPs['lineage'].values]

# According to Wyllie et. al. 2018, drop SNP sets corresponding to branches with fewer than 20 SNPs
# excluded_branches = ['1.2' , '3.1' , '3.1.2' , '4.1.2' , '4.3.4.2.1' , '4.6' , '4.7']
exclude_branch_SNP_thresh = 20

# use lineage as the counts column too, so the index and the column have the same name
excluded_branches = pd.DataFrame(lineage_defining_SNPs.groupby('lineage')['lineage'].count()).query("lineage < @exclude_branch_SNP_thresh").index.values
# print(f"Excluding lineages {excluded_branches} with fewer than {exclude_branch_SNP_thresh} SNPs defining them")
full_length = len(lineage_defining_SNPs)

lineage_defining_SNPs = lineage_defining_SNPs.query("lineage not in @excluded_branches").reset_index(drop=True)
# print(f"Keeping {len(lineage_defining_SNPs)}/{full_length} lineage-defining SNPs from the Coll 2014 scheme")


##########################################################################################################################################################


def check_call_is_SNP(ref_allele , alt_alleles):
	
	'''This function checks to see if Call is a SNP and not an InDel or Structural Variant'''
	
	#check that Reference Allele is 1 base
	if len(ref_allele) == 1:
		
		#check to see if there is no alternate allele
		if alt_alleles == [None]:
			
			good_SNP = True
			
		#if there is an alternate allele(s) check to see that they are all just 1 base
		elif ( sum( [(len(alt_allele) == 1) for alt_allele in alt_alleles] ) == len(alt_alleles) ):
			
			good_SNP = True
			
		#at least 1 alternate allele was longer than 1 base
		else:
			
			good_SNP = False
	
	#reference allele was longer than 1 base        
	else:
		good_SNP = False
			
	return good_SNP


##########################################################################################################################################################


def get_lineage_defining_SNP_depths(reduced_VCF):

	'''
	This function takes as input, the path to the reduced VCF file, then extracts SINGLE base calls from
	the VCF file generated by Pilon specified as a lineage defining SNP from Coll et. al. 2014. 
	The function returns a DataFrame for a single isolate that contains base calling information
	for all of these SNP positions.
	'''

	#path to VCF file
	VCF_file = reduced_VCF

	vcf_reader = vcf.Reader(open(VCF_file , 'r'))

	#create dictionaries to store information for each call
	lineage_dict = {}
	position_dict = {}
	depth_dict = {}
	max_base_count_dict = {}

	#indexer for dataframe containing lineage defining SNPs
	index = 0

	#iterate through each record from VCF file
	for record in vcf_reader:

		#check to see that the record does not correspond to a variant call that is a Structural Variant (SVTYPE)
		if 'SVTYPE' not in record.INFO.keys():

			#position of variant on the Reference Genome
			reference_position = record.POS 

			#reference allele
			ref_allele = record.REF

			#alternate alleles (if there are any)
			alt_alleles = record.ALT

			#check to see if call is at a lineage defining site AND that call is a SNP
			if ( reference_position in list( lineage_defining_SNPs.position ) ) and check_call_is_SNP(ref_allele , alt_alleles):

				######## Retrieve Relevant information for filtering quality of Base Call ########
				# Mean Base Quality @ locus
				BQ = record.INFO['BQ']

				# Mean Mapping Quality @ locus
				MQ = record.INFO['MQ']

				# Number of Reads w/ Deletion 
				DC = record.INFO['DC']

				# Number of Reads w/ Insertion
				IC = record.INFO['IC']  
				
				# Depth of Valid Reads in Pileup
				VD = record.INFO['DP']

				### Filtering Criteria
				#---> Mean Base Quality > 20
				#---> Mean Mapping Quality > 30
				#---> No Reads Supporting Insertions
				#---> No Reads Supporting Deletions
				#---> Number of High Quality Reads >= 25
				if (BQ > 20) and (MQ > 30) and (DC == 0) and (IC == 0) and (VD >= 25): #SNP passed filtering criteria!

					# Valid read depth; some reads may have been filtered
					total_depth = record.INFO['DP']

					#Count of As, Cs, Gs, Ts at locus
					base_counts = record.INFO['BC']

					#most common base - depth
					most_common_base_depth = np.max(base_counts)

					#lineage that is defined by SNP
					lineage_defined = list( lineage_defining_SNPs[lineage_defining_SNPs.position == reference_position].lineage )[0]

					#After filtering for high-quality lineage-defining calls, store all of the pertinent information about the Base Call
					lineage_dict[index] = lineage_defined
					position_dict[index] = reference_position
					depth_dict[index] = total_depth
					max_base_count_dict[index] = most_common_base_depth

					index += 1

	#convert dictionaries to series
	lineage = pd.Series(lineage_dict)
	position = pd.Series(position_dict)
	depth = pd.Series(depth_dict)
	max_base_count = pd.Series(max_base_count_dict)

	#create DataFrame to hold all lineage defining SNPs
	lineage_SNP_depths_from_sample_DF = pd.DataFrame()
	lineage_SNP_depths_from_sample_DF['lineage'] = lineage
	lineage_SNP_depths_from_sample_DF['position'] = position
	lineage_SNP_depths_from_sample_DF['depth'] = depth
	lineage_SNP_depths_from_sample_DF['max_base_count'] = max_base_count

	#calculate the minor depth for each SNP site
	lineage_SNP_depths_from_sample_DF['minor_depth'] = lineage_SNP_depths_from_sample_DF['depth'] - lineage_SNP_depths_from_sample_DF['max_base_count']

	return lineage_SNP_depths_from_sample_DF



def calculate_minor_allele_fraction_per_SNP_set(lineage_SNPs_from_sample_df):

	#get a list of all lineages (i.e. branches) that we have SNP information for
	all_lineages = list( set( list(lineage_SNPs_from_sample_df.lineage) ) )

	#create a series that will store the minor allele fraction (p) for each lineage set
	minor_allele_fraction_per_SNP_set = pd.Series(index = all_lineages)

	for lineage in minor_allele_fraction_per_SNP_set.index:

		#subset to lineage-defining SNPs
		specific_lineage_SNPs_depths = lineage_SNPs_from_sample_df[lineage_SNPs_from_sample_df.lineage == lineage]

		#calculate the Total Depth across all SNP sites for this SNP set
		D = np.sum(specific_lineage_SNPs_depths.depth)

		#calculate the Total Minor Depth
		M = np.sum(specific_lineage_SNPs_depths.minor_depth)

		#calculate the minor allele fraction 
		p = float(M) / float(D)

		#store p for this SNP set in series
		minor_allele_fraction_per_SNP_set[lineage] = p

	#sort values in descending order
	minor_allele_fraction_per_SNP_set.sort_values(ascending = False , inplace = True)
	
	return minor_allele_fraction_per_SNP_set



def calculate_F2(sorted_minor_allele_fraction_per_SNP_set, lineage_SNP_depths_from_sample_df):

    # calculate F2 - get top 2 lineages with the highest minor allele frequencies
    F2_lineages = sorted_minor_allele_fraction_per_SNP_set[:2].index.values

    # subset to SNPs that belong to either SNP set in F2 lineages
    F2_lineage_SNP_depths_df = lineage_SNP_depths_from_sample_df.query("lineage in @F2_lineages")

    try:
        # calculate the Total Depth across all SNP sites for this SNPs belonging to F2 SNP sets
        D2 = np.sum(F2_lineage_SNP_depths_df.depth)

        # calculate the Total Minor Depth
        M2 = np.sum(F2_lineage_SNP_depths_df.minor_depth)

        # calculate the minor allele fraction
        p2 = float(M2) / float(D2)

    except AttributeError:
        # df may be empty!
        p2 = np.nan

    return p2


##########################################################################################################################################################


sample_ID = os.path.basename(sample_dir)
reduced_VCF = os.path.join(sample_dir, "lineage", f"{sample_ID}_lineage_positions.vcf")

# get lineage defining SNP depths for SNPs in all SNP sets
lineage_SNP_depths_from_sample_df = get_lineage_defining_SNP_depths(reduced_VCF)

# calculate minor allele frequency estimates for all SNP sets & sort in descending order
sorted_minor_allele_fraction_per_SNP_set = calculate_minor_allele_fraction_per_SNP_set(lineage_SNP_depths_from_sample_df)

# calculate F2 measure from the depths at lineage defining sites
F2 = calculate_F2(sorted_minor_allele_fraction_per_SNP_set, lineage_SNP_depths_from_sample_df)

with open(F2_fName, 'w+') as file:
    file.write(str(F2) + "\n")